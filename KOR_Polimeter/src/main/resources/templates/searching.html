<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Digital Services Ranking</title>
	<link th:href="@{/css/searching_style.css}" rel="stylesheet">
	<link th:href="@{/css/default_style.css}" rel="stylesheet">
</head>
<body>
<header>
	<h1>
		<a th:href="@{/}">KOR_Polimeter</a>
	</h1>
	<nav>
		<ul>
			<li><a th:href="@{/top10}">TOP10 실시간</a></li>
			<li><a th:href="@{/vote}">투표하기</a></li>
			<div class="vertical-line"></div>
			<!-- 카카오 로그인 URL은 컨트롤러에서 model에 추가한 kakaoUrl 값을 사용 -->
			<li>
				<a th:if="${isLoggedIn == false}" th:href="@{'https://kauth.kakao.com/oauth/authorize?response_type=code&client_id=772c65da382eb8de1916b5771770e5e7&redirect_uri=http://localhost:8080/auth/kakao/callback'}">카카오 로그인</a>
			</li>
			<li>
				<a th:if="${isLoggedIn == true}" th:href="@{'https://kauth.kakao.com/oauth/logout?client_id=772c65da382eb8de1916b5771770e5e7&logout_redirect_uri=http://localhost:8080/logout'}">
					로그아웃
				</a>
			</li>
		</ul>
	</nav>
</header>

<!-- 검색 페이지 상단 배너 -->
<div class="TNB">
	<hr>
	<h2>인물 검색</h2>
	<hr>
</div>
<div class="container">
	<div class="filters">
		<!-- 필터 영역 -->
		<hr>
		<h3>필터</h3>
		<hr>
		<label><input type="radio" name="filter" value="all" checked>전체</label>
		<hr>
		<label><input type="radio" name="filter" value="2030"> 20대 ~ 30대</label>
		<label><input type="radio" name="filter" value="4050"> 40대 ~ 50대</label>
		<label><input type="radio" name="filter" value="60"> 60대~</label>
		<hr>
		<label><input type="radio" name="filter" value="men"> 남</label>
		<label><input type="radio" name="filter" value="women"> 여</label>
	</div>
	<div class="content">
		<hr>
		<!-- 검색 바 영역 -->
		<div class="search-bar">
			<!-- 검색 조건 선택 박스 -->
			<select id="search-type">
				<option value="name">이름</option>
				<option value="keyword">키워드</option>
			</select>

			<!-- 검색 입력 -->
			<input type="text" placeholder="검색하기" id="search" style="width:45%" th:value="${mainquery}">

			<span id="ranking">인기도 TOP5</span>
			<span id="party-label">정당</span>
			<!-- Popularity 텍스트 -->
			<span id="popularity-label">인기도</span>
		</div>
		<div>
			<hr>
			<!-- 인물 리스트 영역 -->
			<ul class="ranking-list" id="ranking-list">
				<!-- JavaScript will render ranking items here -->
			</ul>
			<div id="pagination" class="pagination"></div>
		</div>
	</div>
</div>
<footer>
	<p>Contact us at: sdg0896@gmail.com</p>
	<p>Website created in 2024.</p>
</footer>

<!-- JavaScript for dynamic content -->
<
<script>
	// 300개의 pol_id를 미리 생성
	const polIds = Array.from({ length: 300 }, (_, index) => index + 1); // [1, 2, 3, ..., 300]

	// rankings 배열 초기화
	let rankings = [];
	let originalRankings = []; // 필터링되지 않은 원본 데이터 저장

	// 비동기로 데이터를 가져오고 rankings 배열에 저장
	async function fetchPoliticianData() {
		rankings = [];
		originalRankings = [];
		let totalCount = 0; // 모든 정치인의 count 값을 합산

		// 1. 모든 정치인의 데이터를 가져오고 totalCount 계산
		for (const polId of polIds) {
			try {
				const response = await fetch('http://localhost:8080/api/politician', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
					},
					body: JSON.stringify({ pol_id: polId }),
				});

				if (response.ok) {
					const item = await response.json();

					// count 값을 합산
					totalCount += item.count;

					// 정치인 데이터를 rankings에 추가
					const politician = {
						id: item.id,
						name: item.name,
						party: item.party,
						region: item.region,
						bday: item.bday,
						age: item.age,
						description: item.description,
						gender: item.gender,
						popularity: item.count, // 임시로 count 저장
						image: `images/politicians/${item.party}/${item.name}.jpg`,
					};

					rankings.push(politician);
				} else {
					console.error(`Failed to fetch data for pol_id: ${polId}`);
				}
			} catch (error) {
				console.error(`Error fetching data for pol_id: ${polId}`, error);
			}
		}

		// 2. 각 정치인의 popul 값을 계산하여 업데이트
		rankings = rankings.map((politician) => {
			const popul = (politician.popularity / totalCount) * 100; // popul 계산
			return { ...politician, popul }; // popul 값을 추가한 새로운 객체 반환
		});

		// 3. popul 값을 기준으로 내림차순 정렬
		rankings.sort((a, b) => b.popul - a.popul);

		// 4. 원본 데이터를 저장
		originalRankings = [...rankings];

		// 5. 데이터 로드 완료 후 첫 페이지 렌더링
		renderPage(currentPage);
	}

	// 한 페이지에 표시할 항목 수
	const itemsPerPage = 5;
	let currentPage = 1;

	// 현재 페이지 데이터를 렌더링하는 함수
	function renderPage(page) {
		const rankingList = document.getElementById('ranking-list');
		const startIndex = (page - 1) * itemsPerPage;
		const endIndex = startIndex + itemsPerPage;
		const pageItems = rankings.slice(startIndex, endIndex);

		// 현재 페이지의 랭킹 항목 렌더링
		rankingList.innerHTML = pageItems.map((item, index) => {
			// 전체 rankings 배열에서의 순위 계산
			const globalIndex = startIndex + index;

			// 순위에 따른 뱃지 이미지 설정
			let badge = '';
			if (globalIndex === 0) {
				badge = `<img src="images/first.png" alt="1st Place Badge" class="badge">`; // 1등
			} else if (globalIndex === 1) {
				badge = `<img src="images/second.png" alt="2nd Place Badge" class="badge">`; // 2등
			} else if (globalIndex === 2) {
				badge = `<img src="images/third.png" alt="3rd Place Badge" class="badge">`; // 3등
			} else if (globalIndex === 3) {
				badge = `<img src="images/fourth.png" alt="4th Place Badge" class="badge">`; // 4등
			} else if (globalIndex === 4) {
				badge = `<img src="images/fifth.png" alt="5th Place Badge" class="badge">`; // 5등
			}

			return `
            <li class="ranking-item" data-id="${item.id}">
                <span class="ranking-number">${item.id}</span>
                <div class="ranking-image-container">
                    <img src="${item.image}" alt="${item.name}" width="100%">
                </div>
                <div class="ranking-details">
                    <span class="name">${item.name}</span>
					<span class="ranking-image">${badge}</span>
                    <span class="party">${item.party}</span>
                    <span class="popularity">${item.popul.toFixed(2)}%</span>
                </div>
            </li>
        `;
		}).join('');

		// URL 파라미터 업데이트 (기존 URL 파라미터 유지)
		const urlParams = new URLSearchParams(window.location.search);
		urlParams.set('page', page); // page 파라미터만 업데이트
		const newUrl = `${window.location.pathname}?${urlParams.toString()}`;
		window.history.pushState(null, '', newUrl); // URL 업데이트

		// 페이지네이션 렌더링
		renderPagination();

		// 항목 클릭 시 상세 페이지로 이동
		const rankingItems = document.querySelectorAll('.ranking-item');
		rankingItems.forEach((item, index) => {
			item.addEventListener('click', () => {
				const clickedItem = pageItems[index]; // 현재 페이지의 데이터에서 클릭된 항목 가져오기
				window.location.href = `/details?name=${encodeURIComponent(clickedItem.name)}`;
			});
		});
	}



	// 페이지네이션 버튼 렌더링 함수
	function renderPagination() {
		const pagination = document.getElementById('pagination');
		const totalPages = Math.ceil(rankings.length / itemsPerPage);
		const maxVisiblePages = 10;  // 한 번에 보일 페이지네이션 버튼 수
		const startPage = Math.floor((currentPage - 1) / maxVisiblePages) * maxVisiblePages + 1;
		const endPage = Math.min(startPage + maxVisiblePages - 1, totalPages);

		pagination.innerHTML = ''; // 기존 버튼 초기화

		// 첫 페이지로 이동 버튼
		if (currentPage > 1) {
			const firstPageButton = document.createElement('button');
			firstPageButton.textContent = '<<';
			firstPageButton.addEventListener('click', () => {
				currentPage = 1;
				renderPage(currentPage);
			});
			pagination.appendChild(firstPageButton);
		}

		// 이전 페이지 묶음으로 이동 버튼 (첫 번째 묶음이 아니면 표시)
		if (startPage > 1) {
			const prevButton = document.createElement('button');
			prevButton.textContent = '<';
			prevButton.addEventListener('click', () => {
				currentPage = startPage - 1;
				renderPage(currentPage);
			});
			pagination.appendChild(prevButton);
		}

		// 현재 페이지 범위의 페이지네이션 버튼 생성
		for (let i = startPage; i <= endPage; i++) {
			const button = document.createElement('button');
			button.textContent = i;
			button.classList.add('page-btn');
			if (i === currentPage) {
				button.classList.add('active'); // 현재 페이지 표시
			}
			button.addEventListener('click', () => {
				currentPage = i;
				renderPage(currentPage);
			});
			pagination.appendChild(button);
		}

		// 다음 페이지 묶음으로 이동 버튼 (마지막 묶음이 아니면 표시)
		if (endPage < totalPages) {
			const nextButton = document.createElement('button');
			nextButton.textContent = '>';
			nextButton.addEventListener('click', () => {
				currentPage = endPage + 1;
				renderPage(currentPage);
			});
			pagination.appendChild(nextButton);
		}

		// 끝 페이지로 이동 버튼
		if (currentPage < totalPages) {
			const lastPageButton = document.createElement('button');
			lastPageButton.textContent = '>>';
			lastPageButton.addEventListener('click', () => {
				currentPage = totalPages;
				renderPage(currentPage);
			});
			pagination.appendChild(lastPageButton);
		}
	}

	document.addEventListener('DOMContentLoaded', async () => {
		const searchInput = document.getElementById('search');
		const mainquery = searchInput.value;
		console.log(mainquery+"값입니다.");
		// URL에서 쿼리 파라미터로 현재 페이지를 가져옴
		const urlParams = new URLSearchParams(window.location.search);
		const page = urlParams.get('page');
		currentPage = page ? parseInt(page) : 1;

		await fetchPoliticianData(); // 데이터 로드

		// 필터 라디오 버튼 이벤트 리스너 추가
		const filterRadios = document.querySelectorAll('.filters input[name="filter"]');
		filterRadios.forEach(radio => {
			radio.addEventListener('change', (event) => {
				const filterValue = event.target.value; // 선택된 필터 값
				applyFilter(filterValue); // 필터 적용
			});
		});
		handleSearch(mainquery);
	});

	// 필터 적용 함수
	function applyFilter(filterCriteria) {
		// 필터 조건에 따라 rankings 배열 업데이트
		rankings = originalRankings.filter(item => {
			if (filterCriteria === 'men') {
				return item.gender === 0;
			} else if (filterCriteria === 'women') {
				return item.gender === 1;
			} else if (filterCriteria === '2030') {
				return item.age >= 20 && item.age < 40;
			} else if (filterCriteria === '4050') {
				return item.age >= 40 && item.age < 60;
			} else if (filterCriteria === '60') {
				return item.age >= 60;
			}
			return true; // 기본: 필터 없이 전체 표시
		});

		// 필터링 결과 디버깅
		console.log('Filtered Rankings:', rankings);

		// URL 파라미터 업데이트
		const urlParams = new URLSearchParams(window.location.search);

		// filterCriteria가 유효한 경우에만 URL에 반영
		if (filterCriteria && filterCriteria !== '') {
			urlParams.set('filter', filterCriteria); // filter 값을 설정
		} else {
			urlParams.delete('filter'); // 필터 조건이 없으면 filter 파라미터 제거
		}

		// 페이지를 항상 1로 초기화
		urlParams.set('page', 1);

		// 새로운 URL 생성
		const newUrl = `${window.location.pathname}?${urlParams.toString()}`;
		console.log('Updated URL:', newUrl); // 디버깅: 업데이트된 URL 확인

		// URL 업데이트
		if (window.history && window.history.pushState) {
			window.history.pushState(null, '', newUrl);
			console.log('URL successfully updated in browser');
		} else {
			console.error('pushState is not supported in this browser');
		}

		// 첫 페이지 렌더링
		currentPage = 1;
		renderPage(currentPage);
		renderPagination();
	}

	function handleSearch(query) {
		// 검색어 소문자로 변환
		query = query.toLowerCase();

		// URL에 검색어 반영 (pushState)
		const url = new URL(window.location);
		if (query) {
			url.searchParams.set('query', query); // 'query' 파라미터 추가
		} else {
			url.searchParams.delete('query'); // 검색어가 없으면 파라미터 제거
		}
		window.history.pushState({}, '', url); // URL 변경

		// 검색어에 따라 rankings 필터링
		rankings = originalRankings.filter(item =>
				item.name.toLowerCase().includes(query) ||
				item.party.toLowerCase().includes(query)
		);

		currentPage = 1; // 검색 시 첫 페이지로 이동
		renderPage(currentPage); // 필터링된 결과 렌더링
	}

	document.getElementById('search').addEventListener('input', (event) => {
		handleSearch(event.target.value); // 검색 함수 호출
	});

</script>

</body>
</html>